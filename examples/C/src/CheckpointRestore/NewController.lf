target C

import TaskRetryTemplate, CheckDeadlineAndRetry from "lib/TaskRetryTemplateOnlyReactions.lf"
import Filter, Hold from "../rosace/RosaceController.lf"

preamble {=
  #define REAL_TYPE double

  #define delta_th_eq (1.5868660794926)
  #define delta_e_eq (0.012009615652468)

  #define FAILURE_RATE 30 // % chance

  #ifndef TASK_INFO_T_DEFINED
  #define TASK_INFO_T_DEFINED
  typedef struct task_info_t {
    uint16_t task_num;
    uint16_t dead_line;
    uint16_t num_of_segs;
    uint16_t* wcet;
    uint16_t* optwcet;
  } task_info_t;
  #endif
=}

reactor VaControl50 extends TaskRetryTemplate {
  preamble {=
    const REAL_TYPE K1_intVa =   0.049802610664357;
    const REAL_TYPE K1_Va     = -0.486813084356079;
    const REAL_TYPE K1_Vz     = -0.077603095495388;
    const REAL_TYPE K1_q      = 21.692383376322041;
    const REAL_TYPE Va_eq       = 230.0;

    int Va_control_50(REAL_TYPE Va_f, REAL_TYPE Vz_f, REAL_TYPE q_f, REAL_TYPE Va_c, REAL_TYPE* output, REAL_TYPE* saved_y, REAL_TYPE* saved_integrator,int seg_start_num){
    	static REAL_TYPE y = 0.0;
    	static REAL_TYPE Ts_K1 = 1.0/50.0;
    	static REAL_TYPE integrator = 0.0;

      // // Output
    	// y = K1_intVa * integrator + K1_Va * (Va_f - Va_eq) + K1_Vz * Vz_f + K1_q * q_f + delta_th_eq;
    	// // State
    	// integrator += Ts_K1 * (Va_c - Va_f + Va_eq);
      // *output = y;
      // return 0;

      // Output
      if (seg_start_num <= 1) {
        // Check if input is correct.
    	  y = K1_intVa * integrator + K1_Va * (Va_f - Va_eq) + K1_Vz * Vz_f + K1_q * q_f + delta_th_eq;
        if (rand() % 100 < FAILURE_RATE) {
          return 1;
        } else {
          *saved_y = y;
          *saved_integrator = integrator;
          printf("Va:*saved_integrator = %ld\n", *saved_integrator);
        }
      }
      if (seg_start_num <= 2) {
        // Load the saved value. However, inefficient when no failures between checkpoint 1 and 2.
        integrator = *saved_integrator;
        printf("Va:Before: integrator: %ld\n", integrator);
        // State
    	  integrator += Ts_K1 * (Va_c - Va_f + Va_eq);
        printf("Va:After: integrator: %ld\n", integrator);
        if (rand() % 100 < FAILURE_RATE) {
          return 2;
        } else {
        *output = *saved_y;
        // *output = y;
        }
        return 0;
      }
    }
  =}
  input Va_f: double  // filtered true airspeed
  input Vz_f: double  // filtered vertical climb rate
  input q_f: double   // filtered pitch rate
  input Va_c: double  // Commanded true airspeed setpoint
  output delta_th_c: double

  state Va_f: double
  state Vz_f: double
  state q_f: double
  state Va_c: double
  state delta_th_c: double

  state saved_y: double
  state saved_integrator: double

  reaction(Va_f, Vz_f, q_f, Va_c) {=
    self->saved_y = 0;
    self->saved_integrator = 0;
    self->Va_f = Va_f->value;
    self->Vz_f = Vz_f->value;
    self->q_f = q_f->value;
    self->Va_c = Va_c->value;
  =}

  reaction(advance_lt) -> delta_th_c {=
    // If the failed_seg signal is 0, the Task was finished. Trigger the output value.
    if (advance_lt->value == 0) {
      lf_set(delta_th_c, self->delta_th_c);
    }
  =}

  reaction(trigger_task) -> calculate_lt {=
    lf_schedule_int(calculate_lt, 0, Va_control_50(self->Va_f, self->Vz_f, self->q_f, self->Va_c, &self->delta_th_c, &self->saved_y, &self->saved_integrator, self->seg_start_num));
  =}
}

reactor VzControl50 extends TaskRetryTemplate {
  preamble {=
      const REAL_TYPE K2_intVz   = 0.000627342822264;
      const REAL_TYPE K2_Vz     = -0.003252836726554;
      const REAL_TYPE K2_q       = 0.376071446897134;
      const REAL_TYPE K2_az     = -0.001566907423747;

      int Vz_control_50(REAL_TYPE Vz_f, REAL_TYPE Vz_c, REAL_TYPE q_f, REAL_TYPE az_f, REAL_TYPE* output, REAL_TYPE* saved_y, REAL_TYPE* saved_integrator, int seg_start_num){
        static REAL_TYPE y = 0.0;
        static REAL_TYPE Ts_K2 = 1.0/50.0;
        static REAL_TYPE integrator = 0.0;

        // Output
        if (seg_start_num <= 1) {
          // Check if input is correct.
          y = K2_intVz * integrator + K2_Vz * Vz_f + K2_q * q_f + K2_az * az_f + delta_e_eq;
          if (rand() % 100 < FAILURE_RATE) {
            return 1;
          } else {
            *saved_y = y;
            *saved_integrator = integrator;
            printf("Vz:*saved_integrator = %ld\n", *saved_integrator);
          }
        }
        if (seg_start_num <= 2) {
          // Load the saved value. However, inefficient when no failures between checkpoint 1 and 2.
          integrator = *saved_integrator;
          printf("Vz:Before: integrator: %ld\n", integrator);
          // State
          integrator += Ts_K2 * (Vz_c - Vz_f);
          printf("Vz:After: integrator: %ld\n", integrator);
          if (rand() % 100 < FAILURE_RATE) {
            return 2;
          } else {
          *output = *saved_y;
          // *output = y;
          }
        return 0;
      }
    }
  =}
  input Vz_f: double
  input Vz_c: double
  input q_f: double
  input az_f: double
  output delta_e_c: double

  state Vz_f: double
  state Vz_c: double
  state q_f: double
  state az_f: double
  state delta_e_c: double

  state saved_y: double
  state saved_integrator: double

  reaction(Vz_f, Vz_c, q_f, az_f) {=
    self->saved_y = 0;
    self->saved_integrator = 0;
    self->Vz_f = Vz_f->value;
    self->Vz_c = Vz_c->value;
    self->q_f = q_f->value;
    self->az_f = az_f->value;
  =}

  reaction(advance_lt) -> delta_e_c {=
    // If the failed_seg signal is 0, the Task was finished. Trigger the output value.
    if (advance_lt->value == 0) {
      lf_set(delta_e_c, self->delta_e_c);
    }
  =}

  reaction(trigger_task) -> calculate_lt {=
    lf_schedule_int(calculate_lt, 0, Vz_control_50(self->Vz_f, self->Vz_c, self->q_f, self->az_f, &self->delta_e_c, &self->saved_y, &self->saved_integrator, self->seg_start_num));
  =}
}

reactor VaControl50Retry {
  input Va_f: double
  input Vz_f: double
  input q_f: double
  input Va_c: double
  output delta_th_c: double

  Va_ct_Retry = new VaControl50(
      task_num=2,
      dead_line=10,
      num_of_segs=2,
      wcet = {2, 2},
      optwcet = {1, 1})
  retry = new CheckDeadlineAndRetry()

  Va_ct_Retry.task_info_update -> retry.task_info_update
  Va_ct_Retry.instance_start_time -> retry.instance_start_time_update
  Va_ct_Retry.failed_seg -> retry.failed_seg
  retry.out -> Va_ct_Retry.retry after 0
  Va_f -> Va_ct_Retry.Va_f
  Vz_f -> Va_ct_Retry.Vz_f
  q_f -> Va_ct_Retry.q_f
  Va_c -> Va_ct_Retry.Va_c
  Va_ct_Retry.delta_th_c -> delta_th_c

  reaction(Va_f) -> Va_ct_Retry.new_instance {=
    lf_set(Va_ct_Retry.new_instance, 0);
  =}
}

reactor VzControl50Retry {
  input Vz_f: double
  input Vz_c: double
  input q_f: double
  input az_f: double
  output delta_e_c: double

  Vz_ct_Retry = new VzControl50(
      task_num=1,
      dead_line=10,
      num_of_segs=2,
      wcet = {2, 2},
      optwcet = {1, 1})
  retry = new CheckDeadlineAndRetry()

  Vz_ct_Retry.task_info_update -> retry.task_info_update
  Vz_ct_Retry.instance_start_time -> retry.instance_start_time_update
  Vz_ct_Retry.failed_seg -> retry.failed_seg
  retry.out -> Vz_ct_Retry.retry after 0
  Vz_f -> Vz_ct_Retry.Vz_f
  Vz_c -> Vz_ct_Retry.Vz_c
  q_f -> Vz_ct_Retry.q_f
  az_f -> Vz_ct_Retry.az_f
  Vz_ct_Retry.delta_e_c -> delta_e_c

  reaction(Vz_f) -> Vz_ct_Retry.new_instance {=
    lf_set(Vz_ct_Retry.new_instance, 0);
  =}
}

reactor Stabilizer(period: time = 10 ms) {
  input delta_th_c: double
  input delta_e_c: double
  output delta_thc: double
  output delta_ec: double

  timer t(0, period)

  reaction(t) delta_th_c, delta_e_c -> delta_thc, delta_ec {=
    lf_print("STABILIZER: Current Logical time: %lld msecs", lf_time_logical_elapsed() / MSEC(1));
    lf_set(delta_thc, delta_th_c->value);
    lf_set(delta_ec, delta_e_c->value);
    lf_print("delta_th_c: %ld\ndelta_e_c: %ld\n", delta_th_c->value, delta_e_c->value);
  =}
}

reactor NewController(filter_period: time = 10 ms) {
  // Sensor inputs from aircraft
  // Vertical speed
  input Vz: double
  input Va: double          // True airspeed
  input h: double           // Altitude measurement
  input az: double          // Vertical acceleration
  input q: double           // Pitch rate

  // Command inputs
  // Altitude command
  input c: double
  input s: double           // Speed command

  output delta_thc: double  // Engine control
  output delta_ec: double   // Elevator control

  h_c = new Hold()

  h_f = new Filter(
      period = 100 ms,
      init_x1 = {= h_eq * (1.0 - 1.477888930110354 /*a[1]*/ - 0.049596808318647 /*b1*/) =},
      init_x2 = {= h_eq =},
      a = {0.586756156020839, -1.477888930110354},
      b = {0.049596808318647, 0.059270417591839})
  az_f = new Filter(
      period=filter_period,
      init_x1=0.0,
      init_x2=0.0,
      a = {0.169118914523145, -0.518588903229759},
      b = {0.229019233988375, 0.421510777305010})
  Vz_f = new Filter(
      period=filter_period,
      init_x1=0.0,
      init_x2=0.0,
      a = {0.914975803093201, -1.911199519984605},
      b = {0.001860178914816, 0.001916104193780})
  q_f = new Filter(
      period=filter_period,
      init_x1=0.0,
      init_x2=0.0,
      a = {0.586756156020839, -1.477888930110354},
      b = {0.049596808318647, 0.059270417591839})
  Va_f = new Filter(
      period=filter_period,
      init_x1 = {= Va_eq * (1.0 - 1.911199519984605 /*a[1]*/ - 0.001916104193780 /*b[1]*/) =},
      init_x2 = {= Va_eq =},
      a = {0.914975803093201, -1.911199519984605},
      b = {0.001860178914816, 0.001916104193780})

  Vz_ct = new VzControl50Retry()
  Va_ct = new VaControl50Retry()
  
  h, az, Vz, q, Va -> h_f.x, az_f.x, Vz_f.x, q_f.x, Va_f.x
  c -> h_c.s
  h_f.y -> h_c.x
  
  Vz_f.y, az_f.y, h_c.c, q_f.y -> Vz_ct.Vz_f, Vz_ct.az_f, Vz_ct.Vz_c, Vz_ct.q_f
  
  stabilzer = new Stabilizer(period=filter_period)
  // Without Stabilizer
  // Vz_ct.delta_e_c -> delta_ec

  // With Stabilizer
  Vz_ct.delta_e_c -> stabilzer.delta_e_c
  stabilzer.delta_ec->delta_ec


  Va_f.y, Vz_f.y, s, q_f.y -> Va_ct.Va_f, Va_ct.Vz_f, Va_ct.Va_c, Va_ct.q_f
  // Without Stabilizer  
  // Va_ct.delta_th_c -> delta_thc

  // With Stabilizer
  Va_ct.delta_th_c -> stabilzer.delta_th_c
  stabilzer.delta_thc->delta_thc
}
