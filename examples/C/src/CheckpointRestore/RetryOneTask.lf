/**
 * This project implements a fault-tolerant task execution model using checkpoint and retry
 * mechanisms, and predictive task dropping. The system is designed to simulate execution of
 * multi-segment tasks with faults using logical execution time.
 *
 * 1. Checkpointed Task Execution: Tasks are divided into segments, each with its own worst-case and
 * optimistic execution time. Faults are simulated with probabilistic failures, and task is restored
 * from the checkpoint when fails.
 *
 * 2. Predictive Task Dropping: Upon segment failure, the system evaluates whether retrying will
 * still meet the task's deadline and only proceeds if the deadline constraint is preserved.
 *
 * The purpose of this design is to investigate how logic-based scheduling and retry policies can
 * improve reliability in real-time embedded systems.
 *
 * @author Dongha Kim
 */
target C {
  timeout: 9900 msec
}

import TaskRetryTemplate, CheckDeadlineAndRetry, TaskScheduler from "lib/TaskRetryTemplate.lf"

reactor Task1<T, U> extends TaskRetryTemplate {
  preamble {=
    #define TASK1_SEG1_SLEEP_MSEC  200
    #define TASK1_SEG2_SLEEP_MSEC  200
    #define TASK1_SEG3_SLEEP_MSEC  200
    #define FAILURE_RATE 80 // 80% chance

    int task1_seg1(int in, int* out) {
      lf_sleep(MSEC(TASK1_SEG1_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 1;
      } else {
        *out = in + 1;
        return 0;
      }
    }

    int task1_seg2(int in, int* out) {
      lf_sleep(MSEC(TASK1_SEG2_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 2;
      } else {
        *out = in + 2;
        return 0;
      }
    }

    int task1_seg3(int in, int* out) {
      lf_sleep(MSEC(TASK1_SEG3_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 3;
      } else {
        *out = in + 3;
        return 0;
      }
    }

    int total_task1(int in, int* out, int* saved_value, int checkpoint) {
      if (checkpoint <= 1 && task1_seg1(in, saved_value)) return 1;
      if (checkpoint <= 2 && task1_seg2(*saved_value, saved_value)) return 2;
      if (checkpoint <= 3 && task1_seg3(*saved_value, saved_value)) return 3;
      *out = *saved_value;
      return 0;
    }
  =}
  state saved_value: U

  reaction(new_instance) {=
    self->saved_value = 0;
  =}

  reaction(trigger_task) -> calculate_lt {=
    lf_schedule_int(calculate_lt, 0, total_task1(self->task_input, &self->task_output, &self->saved_value, self->seg_start_num));
    lf_print("Saved_value: %d", self->saved_value);
  =}
}

main reactor {
  task = new Task1<int, int>(
      task_num=1,
      dead_line=3000,
      num_of_segs=3,
      wcet = {300, 300, 300},
      optwcet = {250, 250, 250})
  retry = new CheckDeadlineAndRetry()
  scheduler = new TaskScheduler<int>(period = 5000 msec, in = 5)

  scheduler.trigger -> task.new_instance
  scheduler.task_input -> task.task_input
  task.task_info_update -> retry.task_info_update
  task.instance_start_time -> retry.instance_start_time_update
  task.failed_seg -> retry.failed_seg
  retry.out -> task.retry after 0
}
