target C {
  timeout: 9900 msec
}

preamble {=
  #include <stdlib.h> // rand()
  #include "platform.h" // lf_sleep()
  #define NUMBER_OF_SEGMENTS 3
  #define TASK_DEADLINE 3000 // msecs

  #define SEG1_WCET 300 // msecs
  #define SEG1_OPTWCET 250 // msecs

  #define SEG2_WCET 300 // msecs
  #define SEG2_OPTWCET 250 // msecs

  #define SEG3_WCET 300 // msecs
  #define SEG3_OPTWCET 250 // msecs

  // WCET lookup table.
  static const int TASK1_WCET[] = {
    0, // Index 0 is unused
    SEG1_WCET,
    SEG2_WCET,
    SEG3_WCET
  };

  // OPTWCET lookup table...
  static const int TASK1_OPTWCET[] = {
    0, // Index 0 is unused
    SEG1_OPTWCET,
    SEG2_OPTWCET,
    SEG3_OPTWCET
  };

  typedef struct task_info_t {
    int task_num;
  } task_info_t;
=}

reactor Task (task_num : int = 0) {
  preamble {=
    #define TASK1_SLEEP_MSEC  200
    #define TASK2_SLEEP_MSEC  200
    #define TASK3_SLEEP_MSEC  200
    #define FAILURE_RATE 80 // 80% chance

    int seg1() {
      lf_sleep(MSEC(TASK1_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 1;
      }
      return 0;
    }
    int seg2() {
      lf_sleep(MSEC(TASK2_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 2;
      }
      return 0;
    }
    int seg3() {
      lf_sleep(MSEC(TASK3_SLEEP_MSEC));
      if (rand() % 100 < FAILURE_RATE) {
        return 3;
      }
      return 0;
    }
    int total_task(int checkpoint) {
      int ret = -1;
      if (checkpoint <= 1) {  // Start from task1 if no checkpoint
        ret = seg1();
        if (ret != 0) {
          return ret; // Return failure checkpoint
        }
      }

      if (checkpoint <= 2) {  // Start from task2 if the previous step succeeded
        ret = seg2();
        if (ret != 0){
          return ret; // Return failure checkpoint
        }
      }
      if (checkpoint <= 3) {  // Start from task2 if the previous step succeeded
        ret = seg3();
        if (ret != 0){
          return ret; // Return failure checkpoint
        }
      }
      return 0;
    }
  =}

  input new_instance: int
  input in: int
  logical action advance_lt: int
  output fail: int
  output instance_start_time: time
  output task_info_update: task_info_t
  state task_info: task_info_t = {0}

  reaction(startup) -> task_info_update {=
    self->task_info.task_num = self->task_num;
    lf_set(task_info_update, self->task_info);
  =}

  reaction(new_instance, in) -> advance_lt, instance_start_time{=
    int seg_start_num, num_of_success, failed_task_num;

    if(in->is_present) {
      // When Retry was triggered. in->value should not be 0.
      seg_start_num = in->value;
    } else {
      // When timer is triggering the next instance.
      seg_start_num = 1; // Start from segment 1.
      lf_set(instance_start_time, lf_time_logical_elapsed());
      // When timer triggers.
      lf_print("**** New instance of task %d starting. Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\n", self->task_num, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    }
    failed_task_num = total_task(seg_start_num);
    // Calculate the number of successed segments. If failed_task_num=3 and in seg_start_num=1, 2 segments success.
    num_of_success = failed_task_num - seg_start_num;
    if (num_of_success < 0) {
      // This means failed_task_num was 0 and successed to end of task. Recalculate the number of successed segments.
      num_of_success += NUMBER_OF_SEGMENTS + 1;
    } 

    // Schedule logical action to advance time. 
    lf_print("TASK%d: Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", self->task_num, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));

    // Caluculate the time of the total successed segments.
    int total_success_time = 0; // msecs
    for (int i=0; i < num_of_success; i++){
      total_success_time += TASK1_OPTWCET[seg_start_num+ i];
    }

    if(failed_task_num == 0) {
      // Task is finished. Advance as much as the sucessed segments.
      lf_schedule_int(advance_lt, total_success_time * MSEC(1), 0);
      lf_print("TASK%d: All segments finished. %d task(s) success. Advancing logical time by %lld msecs. \n", self->task_num, num_of_success, total_success_time);
    } else {
      // Segment failed. Advance as much as successed segments + 1 failed segment.
      lf_schedule_int(advance_lt, total_success_time * MSEC(1) + TASK1_WCET[failed_task_num] * MSEC(1), failed_task_num);
      lf_print("TASK%d: Segment %d failed. %d task(s) success. Advancing logical time by %d msecs. \n", self->task_num,failed_task_num, num_of_success, total_success_time + TASK1_WCET[failed_task_num]);
    }
  =}
  reaction(advance_lt) -> fail {=
    lf_set(fail, advance_lt->value);
  =}
}

reactor CheckDeadlineAndRetry {
  input instance_start_time_update: time
  input fail: int
  output out: int
  state instance_start_time: time
  input task_info_update: task_info_t
  state task_info: task_info_t

  reaction(task_info_update) {=
    self->task_info.task_num = task_info_update->value.task_num;
  =}

  reaction(instance_start_time_update) {=
    // Update the instance start time. This can also be implemented by a message by the Task reactor.
    self->instance_start_time = lf_time_logical_elapsed();
  =}
  reaction(fail) -> out{=
    if(fail->value == 0) {
      // 0 means, all segments are finished. Don't trigger the task again, so do nothing.
    } else {
      // Check deadline in logical time. Does not schedule next retry, when deadline violation.

      // Caluculate the additional time required to finish task.
      int total_success_time = 0; // msecs
      for (int i=fail->value; i <= NUMBER_OF_SEGMENTS; i++){
        total_success_time += TASK1_OPTWCET[i];
      }

      instant_t min_instance_finish_time = lf_time_logical_elapsed() + total_success_time * MSEC(1);
      if(min_instance_finish_time > self->instance_start_time + (TASK_DEADLINE * MSEC(1))) {
        lf_print("TASK%d: Current Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.", lf_time_logical_elapsed() / MSEC(1), self->task_info.task_num, lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
        lf_print("TASK%d: ****Logical time deadline violation predicted.\nDeadline is: %lld msecs, while minimum predicted instance finish time is %lld.\nDropping left over tasks, and giving up instance.\n", self->task_info.task_num, (TASK_DEADLINE * MSEC(1) + self->instance_start_time)/ MSEC(1), min_instance_finish_time / MSEC(1));
        // *****This else if tests when there is no deadline prediction! 
        // Don't erase this part.
        // } else if(TASK_DEADLINE * MSEC(1) < lf_time_logical_elapsed() - self->instance_start_time) {
      //   lf_print("\nLogical time deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\nDeadline was: %lld msecs.\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1), (TASK_DEADLINE * MSEC(1) + self->instance_start_time)/ MSEC(1));
      } else {
        // Did not violate predicted deadline.
        lf_set(out, fail->value);
      }
    }
  =}
}

reactor Periodic(period: time = 0 msec) {
  timer t(0, period)
  output out: int

  reaction(startup) {=
    srand(time(NULL));
  =}
  reaction(t) -> out {=
    lf_set(out, 0);
  =}
}

main reactor {
  task = new Task(task_num = 1)
  retry = new CheckDeadlineAndRetry()
  periodic = new Periodic(period = 5000 msec)

  periodic.out -> task.new_instance
  task.task_info_update -> retry.task_info_update
  task.instance_start_time->retry.instance_start_time_update
  task.fail -> retry.fail
  retry.out -> task.in after 0
}
