// For fault tolerance, retry the task. However, does not retry the total task, retries from the last failed subtask.
// User divides the total task into subtasks. If the subtask success, return 0, else, return the task number.
// Even if some tasks success, but misses the deadline, reports deadline violation.
target C {
    timeout: 10 sec
  }
  
preamble {=
  #include <stdlib.h> // rand()
  #include "platform.h" // lf_sleep()
=}
  
// reactor Startup {
//   output out: int

//   // Trigger the first task.
//   reaction(startup) -> out {=
//     lf_set(out, 0);
//   =}
// }

reactor Segment(wcet: time = 20 msec, seg_num: int = 0) {
  preamble {=
  
    #define TASK1_SLEEP_MSEC  200
    #define TASK2_SLEEP_MSEC  200
    #define TASK3_SLEEP_MSEC  200
  
    // // Temporary lookup table...
    // static const int TASK_SLEEP_TIMES[] = {
    //   0, // Index 0 is unused
    //   TASK1_SLEEP_MSEC + TASK2_SLEEP_MSEC + TASK3_SLEEP_MSEC, // For a->value == 1
    //   TASK2_SLEEP_MSEC + TASK3_SLEEP_MSEC, // For a->value == 2
    //   TASK3_SLEEP_MSEC // For a->value == 3
    // };
    
    int task1() {
      lf_sleep(MSEC(TASK1_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        return 1;
      }
      return 0;
    }
    int task2() {
      lf_sleep(MSEC(TASK2_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        return 2;
      }
      return 0;
    }
    int task3() {
      lf_sleep(MSEC(TASK3_SLEEP_MSEC));
      if (rand() % 10 < 8) {  // 80% chance
        return 3;
      }
      return 0;
    }
  =}
    
  input retry: int
  input newtry: int
  output out: int
  reaction(startup) -> out {=
    srand(time(NULL));
    if(self->seg_num == 0) {
      lf_print("Set non-zero seg_num.");
      exit(1);
    // } else if (self->seg_num == 1) {
    //   //  Triggering first task is possible here, but the diagram can look dirty. 
    //   //  Just cleaning up this whole startup reaction is also possible.
    //   // Start first task.
    //   lf_set(out, task1());
    } else {
      // Do nothing.
    }
  =}

  reaction(retry) -> out {=
    if(retry->value == 1 && self->seg_num == 1) {
      lf_set(out, task1());
      lf_print("Starting retry for task%d, Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", retry->value, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    } else if(retry->value == 2 && self->seg_num == 2) {
      lf_set(out, task2());
      lf_print("Starting retry for task%d, Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", retry->value, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    } else if(retry->value == 3 && self->seg_num == 3) {
      lf_set(out, task3());
      lf_print("Starting retry for task%d, Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", retry->value, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    } else {
      // Do nothing.
    }
  =}
  reaction(newtry) -> out {=
    if(newtry->value == 1 && self->seg_num == 1) {
      lf_set(out, task1());
      lf_print("Starting new try for task%d, Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", newtry->value, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    } else if(newtry->value == 2 && self->seg_num == 2) {
      lf_set(out, task2());
      lf_print("Starting new try for task%d, Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", newtry->value, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    } else if(newtry->value == 3 && self->seg_num == 3) {
      lf_set(out, task3());
      lf_print("Starting new try for task%d, Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", newtry->value, lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
    } else {
      // Do nothing.
    }

  =}
}


reactor Retry (wcet: time = 20 msec, seg_num: int = 0, dead_line: time = 0 msec) {
  input in: int // Segment success 0. else fail.
  input instance_start_time_update: time
  output out: int
  logical action check_deadline: int
  logical action trigger: int

  state instance_start_time: time

  reaction(startup){=
    if(self->seg_num == 0) {
      lf_print("Set non-zero seg_num.");
      exit(1);
    }
  =}

  reaction(instance_start_time_update){=
    self->instance_start_time = instance_start_time_update->value;
  =}

  reaction(in) -> check_deadline {=
    if(in->value == 0) {
      // Success.
      lf_print("Task success. Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
      // TODO: How much should I delay when success? Need to delay as much as LET.
      lf_schedule_int (check_deadline, 0, in->value);
    } else {
      // Failed.
      // Need to retry with logical delay.
      // Need few inputs. 1. If failed or success. 2. How much logical time delay.
      lf_print("Task Failed. Advancing logical time by %lld msecs. Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs\n", self->wcet / MSEC(1), lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1));
      lf_schedule_int (check_deadline, self->wcet, in->value); 
    }
  =}
  reaction(check_deadline) -> trigger{=
    // Check deadline in logical time. Does not schedule next retry, when deadline violation.
    //TODO: Now, check if it is schedulable, not doing everything.
    if(self->dead_line < lf_time_logical_elapsed() - self->instance_start_time) {
      lf_print("\nLogical time deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\nDeadline was: %lld msecs.\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1), (self->dead_line + self->instance_start_time)/ MSEC(1));
    // } else if(self->dead_line < lf_time_logical_elapsed() - self->instance_start_time) {
    //   lf_print("\nLogical time deadline violation detected on Logical time: %lld msecs, microstep: %d, Physical time: %lld msecs.\nDeadline was: %lld msecs.\n", lf_time_logical_elapsed() / MSEC(1), lf_tag().microstep, lf_time_physical_elapsed() / MSEC(1), (self->dead_line + self->instance_start_time)/ MSEC(1));
    } else { 
      lf_schedule_int (trigger, 0, check_deadline->value);
    }
  =}

  reaction(trigger) -> out {=
    if(trigger->value == 0) {
      // Success
      lf_set(out, self->seg_num + 1); // 0 means success, no need to retry.
    } else {
      // Failed.
      lf_set(out, self->seg_num); // Failure. Should retry. 
    }
    // out will be sent to both the current and next segment.
    // The current segment will retry looking the value 0, 
    // The next segment will receive -1, does not try and do nothing.
  =}
}

reactor Periodic(start_time: time = 0 msec, period : time = 0 msec) {
  timer t (start_time, period)
  output out: int
  output instance_start_time: time
  reaction (t)->out, instance_start_time{=
    lf_set(out, 1);
    lf_set(instance_start_time, lf_time_logical_elapsed());
  =}
}

reactor Task(wcet: time = 0 msec, period : time = 0 msec, dead_line: time = 0 msec, start_time: time = 0 msec) {

  // input in: int
  // output out: int
  trigger = new Periodic(start_time = start_time, period = period)
  s1 = new Segment(wcet= wcet, seg_num = 1)
  s2 = new Segment(wcet= wcet, seg_num = 2)
  s3 = new Segment(wcet= wcet, seg_num = 3)
  r1 = new Retry(wcet= wcet, seg_num = 1, dead_line = dead_line)
  r2 = new Retry(wcet= wcet, seg_num = 2, dead_line = dead_line)
  r3 = new Retry(wcet= wcet, seg_num = 3, dead_line = dead_line)
  // start.out->r1.in;

  trigger.out ->s1.newtry
  trigger.instance_start_time -> r1.instance_start_time_update
  trigger.instance_start_time -> r2.instance_start_time_update
  trigger.instance_start_time -> r3.instance_start_time_update
  s1.out ->r1.in after 0
  r1.out->s1.retry
  r1.out ->s2.newtry
  
  s2.out ->r2.in after 0
  r2.out->s2.retry
  r2.out ->s3.newtry

  s3.out ->r3.in after 0
  r3.out->s3.retry

  // r3.out -> out

}
  
main reactor {

  task1 = new Task(wcet = 300 msec, period= 3000 msec, dead_line=2000 msec, start_time=0 msec)

  reaction(startup) {=
    srand(time(NULL));
  =}
}
  