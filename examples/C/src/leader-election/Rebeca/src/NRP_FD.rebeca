
//
// This program models a redundant fault tolerant system where a primary node, if and when it fails,
// is replaced by a backup node. The protocol is described in this paper:
//
// Bjarne Johansson; Mats RÃ¥gberger; Alessandro V. Papadopoulos; Thomas Nolte, "Consistency Before
// Availability: Network Reference Point based Failure Detection for Controller Redundancy," paper
// draft 8/15/23.
//
// The key idea in this protocol is that when a backup fails to detect the heartbeats of a primary
// node, it becomes primary only if it has access to Network Reference Point (NRP), which is a point
// in the network.
//
// In the paper, when a backup node detects that it can no longer reach the NRP, then the node
// returns to the WAITING state and requires manual restart. In this version, it just remains a
// non-functional backup. Manual restart will still be required to get things working again.
//
// The Primary sends heartbeats on two networks, 
// if the Backup receives the heartbeats from both networks then all is fine.
// If it receives the heartbeat only from one network the Backup pings the NRP, if NRP replies all is fine, 
// if not 
// If Backup misses heartbeats on both networks then it assumes that the Primary failed and pings NRP, 
// if NRP replies, Backup becomes the Primary
// if not ...
//
// The Rebeca code is adopted from the LF code by Edward Lee and Marjan Sirjani

env int INITIAL_PRIMARY_ID = 10;   // ID of the initial primary.
env int INITIAL_NRP_NETWORK = 1;   // Which network on which to appoint the initial NRP.

env int heartbeat_period = 1000;
env int max_missed_heartbeats = 2;
env int ping_timeout =500;  
env int nrp_timeout = 500;
// Node Modes
env byte WAITING = 0;
env byte PRIMARY = 1;
env byte BACKUP = 2;
env byte FAILED = 3;

env byte NumberOfNetworks = 2;

// Message types
env byte HEARTBEAT = 0;
env byte PING_NRP = 1;
env byte PING_NRP_RESPONSE = 2;
env byte REQUEST_NEW_NRP = 3;
env byte NEW_NRP = 4;

// For testing, set a time for nodes or switches to fail.
// A value 0 means no failure, whereas -1 means nondeterminstic failure.
env int switch1failtime = 0;
env int switch2failtime = 2500;
env int switch3failtime = 0;
env int switch4failtime = 0;

env int node10failtime = 0;
env int node20failtime = 0;


env int network_delay = 1;

reactiveclass Node (4) {

    knownrebecs {
        Switch net1, net2;
    }
   
    statevars {
        byte mode;
        int id;
        int heartbeats_missed_1;
        int heartbeats_missed_2;
        int NRP_network; // Will be 1 or 2 for net1 or net2 network.
        int NRP_switch_id;
        boolean become_primary_on_ping_response;  
        int primary;
        boolean ping_pending;
        boolean ping_timeout_pending;
        boolean nondeterministic_fail;
    }
    
    Node (int my_id, int fail_time) {
        id = my_id;
        mode = WAITING;

        // NRP setup.
        // Manual configuration here is that the initial NRP network is 1.
        NRP_network = INITIAL_NRP_NETWORK;
        // Unknown switch for NRP.
        NRP_switch_id = 0; // Means unknown.
        ping_pending = false;
        ping_timeout_pending = false;
        
        become_primary_on_ping_response = false;
        primary = 0;  // Initially unknown.

        // Configure failure.        
        if (fail_time > 0) {
            fail() after(fail_time);
            nondeterministic_fail = false;
        } else if (fail_time < 0) {
            nondeterministic_fail = true;
        } else {
            nondeterministic_fail = false;
        }

        heartbeats_missed_1 = 0;
        heartbeats_missed_2 = 0;

        startup();
    }
    
    void startup() {
        // If I am the initial primary, broadcast a ping on network 1.
        // The first switch to get this will respond.
        if (id == INITIAL_PRIMARY_ID) {
            primary = id;
            net1.message(PING_NRP, id, 0, 0) after(network_delay);
            ping_pending = true;
            // Instead of scheduling ping_timed_out, we just continue waiting until a ping response arrives. 
        }
    }

    void fail() {
        mode = FAILED;
    }
    
    void send_message(byte message_type, int source, int destination, int payload) {
        net1.message(message_type, source, destination, payload);
        net2.message(message_type, source, destination, payload);
    }

    void sendHeartbeat() {
	    net1.heartbeat(0, id) after(network_delay);
	    net2.heartbeat(1, id) after(network_delay);
    }
   
    msgsrv message(byte message_type, int source, int destination, int payload) {
        NRP_switch_id = switch_id;
        switch(mode) {
        case 0: // WAITING:
            // If this is to be the primary, then expecting a ping response.
            // Otherwise, expecting a new NRP message.
            // Ignore anything else.
            if (id == primary && message_type == PING_NRP_RESPONSE) {
                mode = PRIMARY;
                NRP_switch_id = source;
                // Destination 0 here means broadcast:
                send_message(NEW_NRP, id, 0, source);
                sendHeartbeat();
            } else if (message_type == NEW_NRP) {
                mode = BACKUP;
                primary = source;
                checkForHeartbeat() after(heartbeat_period);
            }
            break;
        case 1: // PRIMARY:
            if (message_type == PING_NRP_RESPONSE) {
                ping_pending = false;
                if (source != NRP_switch_id) {
                    // Have a new NRP.
                    NRP_switch_id = source;
                    // Destination 0 here means broadcast:
                    send_message(NEW_NRP, id, 0, source);
                }
            } else if (message_type == REQUEST_NEW_NRP) {
                NRP_switch_id = 0; // Pending NRP.
                if (NRP_network == 1) {
                    // Try the other network.
                    NRP_network = 2;
                    net2.message(PING_NRP, id, 0, 0);
                } else {
                    NRP_network = 1;
                    net1.message(PING_NRP, id, 0, 0);
                }
                ping_pending = true;
            break;
        case 2: // BACKUP:
            if (become_primary_on_ping_response) {
                mode == PRIMARY;
                become_primary_on_ping_response = false;
                sendHeartbeat();
            }
            ping_pending = false;
            break;
        case 3: // FAILED:
            // Do nothing.
            break;
        }
    }
        
    @Priority(5) msgsrv heartbeat(byte networkId, int senderid) {
        // Only the backup cares about heartbeats.
        if (mode == BACKUP) {
            if (networkId == 1) {
                heartbeats_missed_1 = 0;
            } else  {
                heartbeats_missed_2 = 0;
            }
        }
    }
    
    @Priority(6) msgsrv checkForHeartbeat() {
        // Only the backup checks for heartbeats.
        if (mode == BACKUP) {             
            if (heartbeats_missed_1 > max_missed_heartbeats
                    && heartbeats_missed_2 > max_missed_heartbeats) {
                                  
                // Simultaneous heartbeat misses.
                // In the paper, this is tmoAllNotSimul.
                // For the tmoAllSimul optimization in the paper, we assume that if
                // self->heartbeats_missed_1 == self->heartbeats_missed_2, then most likely, it is
                // the primary that failed, and not the network, so can immediately become the primary.
                // Otherwise, it is possible that one network failed, and then the other failed, in which
                // case, we may have a partitioned network.
                if (heartbeats_missed_1 == heartbeats_missed_2) {
                    // Assume the primary failed. Become primary immediately.
                    mode = PRIMARY;
                    primary=id;
                    sendHeartbeat();
                } else {
                    // Ping the NRP because if we can't access it, we are on the wrong side of
                    // a network partition and could end up with two primaries.
                    if (NRP_network == 1) {    
                        net1.pingNRP(id, NRP_switch_id) after(network_delay);
                    } else {
                        net2.pingNRP(id, NRP_switch_id) after(network_delay);
                    }
                    ping_pending = true;
                    become_primary_on_ping_response = true;
                    pingTimedOut() after(ping_timeout);
                    // Prevent detecting again immediately.
                    heartbeats_missed_1 = 0;
                    heartbeats_missed_2 = 0;
                }
            } else if (heartbeats_missed_1 > max_missed_heartbeats
                    || heartbeats_missed_2 > max_missed_heartbeats) {
                // Heartbeat missed on one network but not yet on the other.
                // Ping the NRP to make sure we retain access to it so that we can be an effective backup.
                // This corresponds to tmoSomeNotAll in the paper.
                if (!ping_pending) {
                    if (NRP_network == 1) {    
                        net1.pingNRP(id, NRP_switch_id) after(network_delay);
	                    ping_pending = true;
	                    pingTimedOut() after(ping_timeout);
                    } else if (NRP_network == 2) {
                        net2.pingNRP(id, NRP_switch_id) after(network_delay);
                        ping_pending = true;
                        pingTimedOut() after(ping_timeout);
                    }
                }
            }
            // Increment the counters so if they are not reset to 0 by the next time,
            // we detect the missed heartbeat.
            heartbeats_missed_1++;
            heartbeats_missed_2++;
            // Schedule the next check.
            checkForHeartbeat() after(heartbeat_period);
        }
    }

    @Priority(7) msgsrv pingTimedOut() {
        ping_timeout_pending = false;
        switch(mode) {
        case 0: // WAITING:
            // Ignore timeout. Just keep waiting.
            break;
        case 1: // PRIMARY:
            if (NRP_switch_id == 0) {
                // Failed to get a new NRP. Declare failure.
                fail();
            } else {
                // Invalidate current NRP.
                NRP_switch_id = 0;

                // Switch networks.
                if (self->NRP_network == 0) self->NRP_network = 1;
          else self->NRP_network = 0;
            net1.new_NRP(id, NRP_network, NRP_switch_id) after(network_delay);

          message_t message = {ping_NRP, self->id, 0, 0};
          lf_set(out[self->NRP_network], message);
          self->ping_pending = true;
          self->ping_timeout_pending = true;
          lf_schedule(ping_timed_out, 0);
            
            break;
        case 2: // BACKUP:
            if (ping_pending) {
                ping_pending = false;
                if (NRP_switch_id != 0) {
		            // Invalidate current NRP.
		            NRP_switch_id = 0;
                    // Send request for new NRP on the other network.
                    if (NRP_network == 1) {
                        net2.new_NRP(id, NRP_network, NRP_switch_id) after(network_delay);
                        NRP_network = 2;
                    } else {
                        net1.new_NRP(id, NRP_network, NRP_switch_id) after(network_delay);
                        NRP_network = 1;
                    }
                }
            }
            break;
        case 3: // FAILED:
            // Do nothing.
            break;
        }
    }
      
    // logical action new_NRP_request_timed_out(nrp_timeout)  
    msgsrv new_NRP_request_timed_out() {
        if (mode == BACKUP) {
            if (NRP_pending) {
                NRP_pending = false;
                if (become_primary_on_ping_response) {
                    become_primary_on_ping_response = false;
                }
            }
        }
    }

    msgsrv request_new_NRP(int iddd) {
        if (mode == PRIMARY) {
            NRP_network++;  // FIXME
            NRP_switch_id = NRPCandidates[NRP_network]; // FIXME
            net1.new_NRP(id, NRP_network, NRP_switch_id) after(network_delay);
            net2.new_NRP(id, NRP_network, NRP_switch_id) after(network_delay);
            NRP_pending = true;
        } 
    }
    
    msgsrv new_NRP(int mid, int mNRP_network, int mNRP_switch_id) {
        NRP_network = mNRP_network;
        NRP_switch_id = mNRP_switch_id;
    }
        
    msgsrv runMe() {
        if (nondeterministic_fail && ?(true,false)) fail();
        switch(mode) {
        case 0: // WAITING : 
            if (init) {
                if (id == primary) {
                    mode = PRIMARY;
                    NRP_network++;
                    if (NRP_network < NumberOfNetworks) {
                        NRP_switch_id = NRPCandidates[NRP_network]; // FIXME
                        if (NRP_network == 1) {
                            net1.new_NRP(id, NRP_switch_id);
                        } else {
                            net2.new_NRP(id, NRP_switch_id);
                        }
                    } else {
                        NRP_network=NumberOfNetworks;
                    }
                } else {
                    mode =BACKUP;
                }
                init=false;
            }     
            break;
          
        case 1: // PRIMARY :
// FIXME: Why are these commented out? 
//                         net1.heartbeat(0, id) after(network_delay);
//                         net2.heartbeat(1, id) after(network_delay);
            if (NRP_network == 1) {    
                ping_pending = true;
                net1.pingNRP(id, NRP_switch_id) after(5);
                pingTimedOut() after(ping_timeout);
            } else {
                ping_pending = true;
                net2.pingNRP(id, NRP_switch_id) after(5);
                pingTimedOut() after(ping_timeout);
            }
            NRP_pending = true;
                         
            break;
        case 2: // BACKUP : 
            heartbeats_missed_1++;
            heartbeats_missed_2++;
             
            if (heartbeats_missed_1 > max_missed_heartbeats
                    && heartbeats_missed_2 > max_missed_heartbeats) {
                                  
                if (heartbeats_missed_1==heartbeats_missed_2 && heartbeats_missed_2==max_missed_heartbeats+1) {
                    mode = WAITING;
                    NRP_network = 1;
                     
                    heartbeats_missed_1 = 0; // Prevent detecting again immediately.
                    heartbeats_missed_2 = 0;
                    primary=id;
                    NRP_pending = true;
                } else {
                    heartbeats_missed_1 = (heartbeats_missed_1>max_missed_heartbeats+2)?max_missed_heartbeats+2:heartbeats_missed_1;
                    heartbeats_missed_2 = (heartbeats_missed_2>max_missed_heartbeats+2)?max_missed_heartbeats+2:heartbeats_missed_2;
                    if (NRP_network == 1) {    
                        ping_pending = true;
                        NRP_network = -1;
                        net1.pingNRP(id, NRP_switch_id) after(5);
                        pingTimedOut() after(ping_timeout);
                    } else {
                        ping_pending = true;
                        NRP_network=-1;                                           
                        net2.pingNRP(id, NRP_switch_id) after(5);
                        pingTimedOut() after(ping_timeout);
                    }
                    NRP_pending = true;
                }
            } else if (heartbeats_missed_1 > max_missed_heartbeats
                    || heartbeats_missed_2 > max_missed_heartbeats) {
                            
                if (NRP_network==1 && heartbeats_missed_1 > max_missed_heartbeats) {
                    ping_pending = true;
                    net1.pingNRP(id, NRP_switch_id) after(5);
                    pingTimedOut() after(ping_timeout);
                } else if (heartbeats_missed_2 > max_missed_heartbeats) {
                    ping_pending = true;
                    net2.pingNRP(id, NRP_switch_id) after(5);
                    pingTimedOut() after(ping_timeout);
                }
                heartbeats_missed_1 = (heartbeats_missed_1>max_missed_heartbeats+2)?max_missed_heartbeats+2:heartbeats_missed_1;
                heartbeats_missed_2 = (heartbeats_missed_2>max_missed_heartbeats+2)?max_missed_heartbeats+2:heartbeats_missed_2;
            }
            break;
               
        case 3: // FAILED : 
            break;
          
        } 
      
        self.runMe() after(heartbeat_period);
    }
     
    
}
    
/**
 * A Switch has a connected Node and a connected Switch.
 * Note that this will only work for a very specific network topology.
 */
reactiveclass Switch(10) {
    knownrebecs {
        Node connected_node;
        Switch connected_switch;
    }
    
    statevars {
        int id;
        boolean failed;
        boolean nondeterministic_fail;
    }
    
    Switch (int my_id, int fail_time) {
        id = my_id;
        failed = false;
        if (fail_time > 0) {
            switchFail() after(fail_time);
            nondeterministic_fail = false;
        } else if (fail_time < 0) {
            nondeterministic_fail = true;
        } else {
            nondeterministic_fail = false;
        }
    }
    
    void fail() {
        failed = true;
    }
    
    msgsrv message(byte message_type, int source, int destination) {
        if (nondeterministic_fail && ?(true,false)) fail();
        if (!failed) {
            if (message_type == PING_NRP) {
                if (destination == id || destination == 0) {
                    // I am being pinged or it's a general ping.
                    // Respond to the switch or node that is sending.
                    if (source <= 9) {
                        // Source is a switch (shouldn't happen).
                        connected_switch.message(PING_NRP_RESPONSE, id, source) after(network_delay);
                    } else {
                        // Source is a node.
                        connected_node.message(PING_NRP_RESPONSE, id, source) after(network_delay);
                    }
                } else {
                    // I am not the NRP and it's not a general ping.
                    // Forward to the next switch.
                    connected_switch.message(message_type, source, destination) after(network_delay);
                }
            } else {
                // Forward the message.
                if (source <= 9) {
                    // Source is a switch. Send to the connected node.
                    connected_node.message(message_type, source, destination);
                } else {
                    // Source is a node. Send to the connected switch.
                    connected_switch.message(message_type, source, destination);
                }
            }
        }
    }
}

main {
    // Switches have IDs less than 10.
    @Priority(1) Switch switch1(node10, switch2):(1, switch1failtime);
    @Priority(1) Switch switch2(node20, switch1):(2, switch2failtime);
    @Priority(1) Switch switch3(node10, switch4):(3, switch3failtime);
    @Priority(1) Switch switch4(node20, switch3):(4, switch4failtime);
    // Nodes have IDs larger than 10.
    @Priority(2) Node node10(switch1, switch3):(10, node10failtime);
    @Priority(2) Node node20(switch2, switch4):(20, node20failtime);
}
